{
  "title": "Parallel Claude 4: Multi-Agent Git Workflows",
  "summary": "This tutorial demonstrates an advanced agentic coding workflow using Claude Code and the Claude 4 Opus model. It introduces a 'Parallel Agentic Coding' technique where multiple AI agents operate simultaneously in isolated Git Worktrees to implement the same specification. By leveraging the non-deterministic nature of LLMs, this workflow generates multiple distinct implementations ('futures') of a feature, allowing the engineer to review, select, and merge the highest-quality version into the main codebase.",
  "steps": [
    {
      "time": "02:28",
      "action": "Select Model (Claude 4 Opus)",
      "tool": "Claude Code",
      "reasoning": "Selecting the state-of-the-art model (Opus 4) ensures the highest reasoning capability for complex, autonomous engineering tasks."
    },
    {
      "time": "02:44",
      "action": "Define Specification (Plan)",
      "tool": "Markdown (specs/ui-revamp.md)",
      "reasoning": "Agentic workflows require clear, written plans (PRDs/Specs) to function effectively without constant human oversight. 'Planning is the new prompting.'"
    },
    {
      "time": "03:28",
      "action": "Initialize Parallel Worktrees",
      "tool": "Custom Command (/simple-init-parallel)",
      "reasoning": "Uses `git worktree` to duplicate the codebase into isolated directories (`trees/`), allowing multiple agents to modify files simultaneously without conflict."
    },
    {
      "time": "04:43",
      "action": "Configure Isolated Environments",
      "tool": "Claude Code / Bash",
      "reasoning": "Sets up dependencies (`bun i`) and unique ports in `vite.config.ts` for each worktree so all versions can run concurrently for comparison."
    },
    {
      "time": "07:26",
      "action": "Execute Parallel Agents",
      "tool": "Custom Command (/exe-parallel)",
      "reasoning": "Spins up multiple autonomous agents, assigning each a specific worktree and the implementation plan. This scales engineering effort by running jobs in parallel."
    },
    {
      "time": "09:33",
      "action": "Autonomous Implementation",
      "tool": "Claude 4 Opus Agents",
      "reasoning": "Agents work asynchronously to implement the spec. Due to LLM non-determinism, each agent produces a unique solution path and code structure."
    },
    {
      "time": "18:15",
      "action": "Generate Review Script",
      "tool": "Claude Code",
      "reasoning": "Creates a script (`start_tree_clients.sh`) to launch all three front-end versions simultaneously, facilitating immediate visual comparison."
    },
    {
      "time": "19:20",
      "action": "Visual Review & Selection",
      "tool": "Web Browser",
      "reasoning": "The engineer evaluates the 'multiple futures' generated by the agents to pick the best UI/UX implementation (Version 2 in this case)."
    },
    {
      "time": "21:45",
      "action": "Merge Best Implementation",
      "tool": "Git / Cursor",
      "reasoning": "The selected worktree branch is committed and merged back into the main branch, effectively collapsing the parallel futures into the single best outcome."
    }
  ],
  "key_takeaways": [
    "Leverage LLM Non-Determinism: Running the same prompt multiple times produces different results; parallel execution turns this 'bug' into a feature by offering multiple solutions to choose from.",
    "Git Worktrees are Essential: Worktrees provide the necessary file-system isolation for multi-agent workflows within a single repository.",
    "Compute Scales Quality: Trading compute resources (running multiple expensive agents) for 'Best of N' selection results in higher quality code than single-shot generation.",
    "Plan-Driven Engineering: Moving from iterative chat to spec-based execution allows for long-running, autonomous agentic jobs."
  ]
}